
Annotations:
    [addr] = register or memory address (subset of gio)
    [val] = generic immediate operand
    [dt] = datatype
    [name] = alphanumeric string (Cannot start with a numeric)
    [*...] = optional

Datatypes:
    i[8/16/32/64] = signed integer
    u[8/16/32/64] = unsigned integer
    f[32/64] = floating point value
    addr = [u64]

Generic immediate operands:
    @[u64Exp]                               Dereference u64Exp (C: *u64Exp)


Registers:
    $sp                                     Stack pointer
    $fp                                     Frame pointer
    $lc                                     Loop counter
    $ac                                     General purpose register (accumulator)
    $cp                                     Code pointer
    $ec                                     Exit/Error code


Instructionset:
    mov.[dt] : [addr] : [val]                Store value of gio at r/m

    add.[dt] : [addr] : [val]                Add value of gio to r/m
    sub.[dt] : [addr] : [val]                Subtract value of gio from r/m
    mul.[dt] : [addr] : [val]                Multiply value at r/m with value of gio
    div.[dt] : [addr] : [val]                Divide value at r/m by value of gio

    conv.[dt] : [r/m] : [dt]

    push.[dt]
    pop.[dt]
    pushc.[dt] : [val]                      Push a value onto the stack
    pop.[dt]                                Pop a value from the stack

    pushf                                   Push a new stack frame
    popf                                    Pop a stack frame

    jmp : [addr]
    jeq.[dt] : [addr] : [val] : [val]
    jne.[dt] : [addr] : [val] : [val]

    exit

Other:
    #label : [name]                         Create a label with name name holding the current code pointer
    #alias : [name] : [literal]             Store any literal under a specific name
    #module : [modName]                     Links the current file to the given module name
    #reqmod : [filename] : [modName]        Mark a file as a requested module
    #static : [name] : [size]               Shortcut for: label : [name] \ add.u64 : $sp : [size]
    #manperm : [single/group] : [name]      Request a mandatory permission for an external function
    #optperm : [single/group] : [name]      Request a optional permission for an external function


Example:
    #static : var1 : 4                      / Reserve 4 bytes on the static stack
    #static : arr1 : 64                     / Reserve 4 * 16 bytes on the static stack
    mov.i32 : var1 : -53                    / Store i32 value -53 at address of var1
    add.i32 : var1 : @var1                  / Add value stored at address of var1 to var1

    #static : add1 : 8                      / Reserve 8 bytes on the static stack
    mov.i64 : add1 : 36                     / Add i64 value 36 to var1

    add.i64 : $ac : @$ac                    / Multiply the content of register $ac by 2

    mov.i32 : [arr1+36] : -12               / Store i32 value -12 at address of arr1 with an offset of 36 bytes
    mov.i32 : [arr1+8] : @[arr1+12]         / Store i32 value stored at address of arr1 with an offset of 12 bytes at address of arr1 with an offset of 8 bytes


Storage locations:
    Static stack: Modifiable, determined at compile time or allocated during interpretation, storage for global vars, can be stored on disk
    Dynamic stack: Modifiable, storage for local vars
    Dynamic memory: Modifiable, storage for dynamically allocated data
    Code memory: Non-modifiable, storage for executable code